Принцип инверсии зависимости (Dependency Inversion Principle – DIP):

* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Один из фундаментальных принципов проектирования, лежащий в основе 
Dependency Injection, в том числе.

Принцип заключается в требовании, чтобы зависимости, нужные
классу для создания его функциональности, были получены им не 
"напрямую" (созданием ссылки на нужный класс), а через "третью
сторону", через некую абстракцию, поддерживающую нужный интерфейс,
но ни в коем случае не конкретную реализацию.

В нашем примере есть два класса - Телефон и Имейл - которые умеют
сообщать о погоде. Класс, который комбинирует их функциональность,
получает на них прямые зависимости, буквально создавая их и
используя в своей бизнес-логике.

Если в будущем в систему будет добавлена еще одна система оповещений,
к примеру, звуковая об урагане, которая будет совершать 
проигрывание звукового файла, то класс WeatherTracker вынужден
будет под это "подстроиться", чтобы дать возможность принять файл
и проиграть его. Таким образом, этот трекер зависит от конкретной
реализации нового класса.

Мы же хотим избежать этого. Мы хотим написать класс так, чтобы он 
зависел от непоколебимой в силу своей абстракции сущности Notifier,
которая будет являться способом запроса нужной функциональности
извне класса.

Таким образом, как бы не был реализован любой новый класс, который
поддерживает интерфейс Notifier, класс WeatherTracker всегда будет 
вызывать только метод этого интерфейса.

Поэтому инверсию зависимостей сводят часто к тому, чтобы избавиться от наследования,
а заменить ее агрегацией, комбинируя нужные зависимости.



