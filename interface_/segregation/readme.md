Interface segregation

**Программные сущности не должны зависеть от методов, которые они не используют.**

Представим себе, что в основе взаимодействия классов нашей системы лежит
единственный интерфейс, который, как нам кажется, верно семантически
описывает сущность. 

В нашем примере такой сущностью является Птица - Bird, которая обладает 
способностью летать и линять.

Поскольку мы предоставляем наш интерфейс другим классам, то
возникает опасность, что эти классы, имплементируя интерфейс,
должны будут поддерживать методы, диктуемые интерфейсом,
которые, тем не менее, противоречат семантике.

В нашем примере Орел умеет и летать и линять. Но Пингвин не 
умеет летать, но поскольку мы спроектировали нашу систему таким образом,
что вся она зависит от единственной сущности - Птица - то пингвин,
ради сохранения семантики своего поведения, вынужден при реализации
метода летать() бросать исключение, говорящее о том, что пингвин
не будет поддерживать эту операцию.

Наличие одного базового класса (или интерфейс) приводит к тому, 
что семантика реализующего класса загрязняется лишней информацией.
Что в свою очередь приводит к сильному связыванию кода, что мы всеми силами
хотим избежать.

Поэтому всегда лучше конструировать конечные сущности, поддерживая
определенные способности разными интерфейсами, так, чтобы классы
не были вынуждены поддерживать операции интерфейса, которые им не специфичны.
